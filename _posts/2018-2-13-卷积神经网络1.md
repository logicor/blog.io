#卷积神经网络1

			<div id="cnblogs_post_body" class="blogpost-body"><p><span style="font-size: 14pt;"><strong>1.</strong></span><strong><span style="font-size: 14pt;">卷积操作实质：</span></strong></p>
<p><span style="font-size: 14pt;"><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp; 输入图像（input volume），在深度方向上由很多slice组成，对于其中一个slice，可以对应很多神经元，神经元的weight表现为卷积核的形式，即一个方形的滤波器（filter）（如3X3），这些神经元各自分别对应图像中的某一个局部区域（local region），用于提取该区域的特征。如果该slice对应的神经元参数共享，那么相当于只有一个卷积核作用于所有的局部区域（类似于图像滤波了）。一个局部区域可以称为一个block，如果将所有的block</span></span><span style="font-size: 15px; line-height: 22.5px;">拉成一个个列向量（因为神经元作用本来就定义为将输入向量和参数向量进行内积操作，y=w0x0+w1x1+...+wnxn</span><span style="font-size: 15px; line-height: 22.5px;">），则我们可以得到很多这些列向量组成的局部区域数据矩阵，再将神经元的weight拉成一个个行向量，这样就得到一个参数矩阵（如果参数共享，那么该矩阵行数为slice的个数</span><span style="font-size: 15px; line-height: 22.5px;">），然后将数据矩阵和参数矩阵进行点积操作，得到卷积后结果，其实就是将所有的filter和所有的局部区域分别进行点积操作，当然这个结果还需要重新reshape到期望的输出尺寸。这个过程其实也解释了为什么神经元的参数可以保存在一个个filter中，该网络层为什么称为卷积层。</span></p>
<p><span style="font-size: 15px; line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; 下图转自https://www.zhihu.com/question/28385679</span></p>
<p><span style="font-size: 15px; line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://images2015.cnblogs.com/blog/621155/201611/621155-20161109175820233-1979177972.png" alt=""></span></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://images2015.cnblogs.com/blog/621155/201611/621155-20161109175844108-665719534.png" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://images2015.cnblogs.com/blog/621155/201611/621155-20161109175902655-488730476.png" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://images2015.cnblogs.com/blog/621155/201611/621155-20161109175929952-1076690146.png" alt=""></p>
<p>最后一页没画，但是基本上就是Filter Matrix乘以Feature Matrix的转置，得到输出矩阵Cout x (H x W)，就可以解释为输出的三维Blob（Cout x H x W）。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt; line-height: 22.5px;">2.经过卷积后输出图像尺寸：</span></strong></p>
<p><span style="font-size: 14pt; line-height: 22.5px;">&nbsp; &nbsp; &nbsp;<span style="font-size: 15px;">假设输入图像尺寸为<em>W</em>，卷积核尺寸为<em>F</em>，步幅（stride）为<em>S</em>（卷积核移动的步幅），Padding使用<em>P</em>（用于填充输入图像的边界，一般填充0）,那么经过该卷积层后输出的图像尺寸为（<em>W</em>-<em>F</em>+2<em>P</em>）/<em>S</em>+1。<br></span></span></p>
<p><span style="font-size: 14pt;"><strong><span style="line-height: 22.5px;">3.池化</span></strong></span></p>
<p><span style="font-size: 14pt;"><strong><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp;</span></strong><span style="line-height: 22.5px; font-size: 15px;">池化层通过减小中间过程产生的特征图的尺寸（下采样，图像深度不变），从而减小参数规模，降低计算复杂度，也可以防止过拟合。池化是分别独立作用于图像深度方向上的每个slice，一般使用Max操作（在一个局部区域内取最大值代表该区域），即最大池。通常池化层的空间尺寸（spatial extent）不应过大，过大会丢失太多结构信息，一般取<em>F</em>=3<em>,S</em>=2或者<em>F</em>=2<em>,S</em>=2<em>。</em>也有人不建议使用池化，而是在卷积层增大stride来降低图像尺寸。</span><span style="line-height: 22.5px; font-size: 15px;"><br></span></span></p>
<p><strong><span style="font-size: 14pt;">4.全连接</span></strong></p>
<p><strong><span style="font-size: 14pt;">&nbsp; </span></strong><span style="font-size: 14pt;">&nbsp; &nbsp;<span style="font-size: 15px;">一个</span></span><span style="font-size: 14pt;"><span style="font-size: 15px;">神经元作用于整个slice，即filter的尺寸恰好为一个slice的尺寸，这样输出一个值，如果有n个filter，则输出长度为n的向量，一般全连接层的输出为类别/分数向量（class scores&nbsp;）。</span></span></p>
<p><strong><span style="font-size: 14pt;">5. 网络的结构</span></strong></p>
<p><strong><span style="font-size: 14pt;">&nbsp; &nbsp; </span></strong><span style="font-size: 15px;">网络的一般结构为：</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;INPUT &nbsp;&nbsp;<span style="color: #ff0000;"><strong>-&gt;</strong></span>&nbsp; &nbsp;<span style="color: #ff9900;">[</span><span style="color: #00ff00;">[</span>CONV <strong><span style="color: #ff00ff;">-&gt;</span> </strong>RELU<span style="color: #00ff00;">]</span>*N <span style="color: #ff00ff;"><strong>-&gt;</strong></span> POOL?<span style="color: #ff9900;">]</span>*M &nbsp;&nbsp;<span style="color: #ff0000;"><strong>-&gt;</strong></span>&nbsp; &nbsp;<span style="color: #0000ff;">[</span>FC<span style="color: #ff00ff;"><strong> -&gt;</strong></span> RELU<span style="color: #0000ff;">]</span>*K &nbsp;&nbsp;<span style="color: #ff0000;"><strong>-&gt; &nbsp;</strong></span> FC</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;INPUT：输入</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;CONV：卷积层</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;RELU：激活函数</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;POOL：池化层，这里的问号表示该层是可选的</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;FC：全连接层</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp;<code class="highlighter-rouge">N &gt;= 0</code>&nbsp;（通常<code class="highlighter-rouge">N &lt;= 3）</code>,&nbsp;<code class="highlighter-rouge">M &gt;= 0</code>,&nbsp;<code class="highlighter-rouge">K &gt;= 0</code>&nbsp;（通常&nbsp;<code class="highlighter-rouge">K &lt; 3)</code><br></span></p>
<p><strong><span style="font-size: 14pt;">6.其他</span></strong></p>
<p><strong><span style="font-size: 14pt;">&nbsp; &nbsp;</span></strong><span style="font-size: 15px;">（1）尽量使用多层fliter尺寸小的卷积层代替一层filter较大的卷积层。</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为使用多层filter较小的卷积层所能观察到的区域大小和一层filter较大的卷积层是相同的，但是前者可以看到更加抽象的特征，提取的特征表达性能更佳。</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;此外，前者引入的参数规模相比后者更小。比如，使用3层filter为3X3的卷积层代替1层filter为7X7的卷积层，假设输入的volume为C个通道<em>，</em>则前者参数</span></p>
<p><span style="font-size: 15px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;个数为<span id="MathJax-Span-510" class="mn">3<span id="MathJax-Span-511" class="mo">×<span id="MathJax-Span-512" class="mo">(<span id="MathJax-Span-513" class="mi">C<span id="MathJax-Span-514" class="mo">×<span id="MathJax-Span-515" class="mo">(<span id="MathJax-Span-516" class="mn">3<span id="MathJax-Span-517" class="mo">×<span id="MathJax-Span-518" class="mn">3<span id="MathJax-Span-519" class="mo">×<span id="MathJax-Span-520" class="mi">C<span id="MathJax-Span-521" class="mo">)<span id="MathJax-Span-522" class="mo">)<span id="MathJax-Span-523" class="mo">=<span id="MathJax-Span-524" class="mn">27<span id="MathJax-Span-525" class="msubsup"><span id="MathJax-Span-526" class="mi">C^2，而后者为<span id="MathJax-Element-61-Frame" class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span id="MathJax-Span-492" class="math"><span id="MathJax-Span-493" class="mrow"><span id="MathJax-Span-494" class="mi"></span></span></span><span class="MJX_Assistive_MathML">C×(7×7×C)=49C^2，明显前者引入的参数更少。</span></span><span id="MathJax-Span-527" class="mn"><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp;（2）为什么使用padding？</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;使用padding的好处是使得卷积前后的图像尺寸保持相同，可以保持边界的信息。一般padding的大小为<em>P</em>=(<em>F</em>-1)/2，其中<em>F</em>为filter的尺寸。如果不使用 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paddding，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">则要仔细跟踪图像尺寸的变化，确保每一层filter和stride正确的被使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp;（3）为什么stride一般设为1？</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stride设为1实际表现效果更好，将下采样的工作全部交给池化层。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp;（4）输入层（input layer）尺寸一般应该能被2整除很多次，比如32（CIFAR-10）,64,96（STL-10），224（common ImageNet ConvNets），384和512。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp;（5）尽量使用filter较小（3x3 or 至多 5x5）的卷积层，如果要使用较大的filter（比如7x7），一般也只在第一个卷积层。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp;（6）有时候由于参数太多，内存限制，会在第一个卷积层使用较大filter（7x7）和stride（2）（参考&nbsp;ZF Net），或者filter（11x11），stride（4）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 15px;"><span class="mn"><span class="mo"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mn"><span class="mo"><span class="mn"><span class="mo"><span class="mi"><span class="mo"><span class="mo"><span class="mo"><span class="mn"><span class="msubsup"><span class="mi"><span class="MathJax" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo>&amp;#x00D7;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mn>7</mn><mo>&amp;#x00D7;</mo><mi>C</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>49</mn><msup><mi>C</mi><mn>2</mn></msup></math>"><span class="MJX_Assistive_MathML">&nbsp; &nbsp; &nbsp; &nbsp; （参考&nbsp;AlexNet）。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="http://www.cnblogs.com/njust-ycc/category/860626.html" target="_blank">深度学习</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(5721381,cb_blogId,1);green_channel_success(this,'谢谢推荐！');">好文要顶</a>
            <a id="green_channel_follow" onclick="follow('c1027a3a-14be-e311-8d02-90b11c0b17d6');" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="//common.cnblogs.com/images/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="//common.cnblogs.com/images/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/njust-ycc/" target="_blank"><img src="//pic.cnblogs.com/face/621155/20160730153326.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/njust-ycc/">coollife</a><br>
            <a href="http://home.cnblogs.com/u/njust-ycc/followees">关注 - 2</a><br>
            <a href="http://home.cnblogs.com/u/njust-ycc/followers">粉丝 - 4</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow('c1027a3a-14be-e311-8d02-90b11c0b17d6');return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(5721381,'Digg')">
        <span class="diggnum" id="digg_count">1</span>
    </div>
    <div class="buryit" onclick="votePost(5721381,'Bury')">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/njust-ycc/p/5734749.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/njust-ycc/p/5734749.html" title="发布于2016-08-06 16:57">Android学习笔记之消息机制</a><br></div>
</div>


		